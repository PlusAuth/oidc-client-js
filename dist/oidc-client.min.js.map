{"version":3,"file":"oidc-client.min.js","names":["storedKeys: string[]","onLoadTimeoutId: any","internalSessionState: string | null","timer: any","ret: string[]","result: Record<string, string>","value","body: any","timeoutId: any","closeId: any","handlers: Record<string, any>","parsedUrl: URL","tokenResult: any","finalState: any","user: any","parsedIDToken: any"],"sources":["../src/constants/events.ts","../src/errors.ts","../src/helpers/event_emitter.ts","../src/helpers/state_manager/state_store.ts","../src/helpers/state_manager/in_memory.ts","../src/helpers/state_manager/local_storage.ts","../src/helpers/timer.ts","../src/utils/iframe.ts","../src/utils/check_session_iframe.ts","../src/utils/url.ts","../src/utils/crypto.ts","../src/utils/jose.ts","../src/utils/request.ts","../src/utils/object.ts","../src/utils/oidc.ts","../src/utils/popup.ts","../src/utils/tab_utils.ts","../src/client.ts","../src/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/indent */\nexport const Events = {\n  USER_LOGOUT: \"user_logout\",\n  USER_LOGIN: \"user_login\",\n  SILENT_RENEW_SUCCESS: \"silent_renew_success\",\n  SILENT_RENEW_ERROR: \"silent_renew_error\",\n  SESSION_CHANGE: \"session_change\",\n} as const\n\nexport type EventTypes =\n  | \"user_logout\"\n  | \"user_login\"\n  | \"silent_renew_success\"\n  | \"silent_renew_error\"\n  | \"session_change\"\n  | \"session_error\"\n","export class OIDCClientError extends Error {\n  error: string\n\n  error_description?: string\n\n  public constructor(error: string, error_description?: string) {\n    super(`${error}${(error_description && ` - ${error_description}`) || \"\"}`)\n    this.name = \"OIDCClientError\"\n    this.error = error\n    this.error_description = error_description\n  }\n}\n\nexport class AuthenticationError extends OIDCClientError {\n  state?: string\n\n  error_uri?: string\n\n  constructor(error: string, error_description?: string, state?: string, error_uri?: string) {\n    super(error, error_description)\n    this.name = \"AuthenticationError\"\n    this.state = state\n    this.error_uri = error_uri\n  }\n}\n\nexport class StateNotFound extends AuthenticationError {\n  state?: string\n\n  constructor(error: string, state?: string) {\n    super(error)\n    this.name = \"StateNotFound\"\n    this.state = state\n  }\n}\n\nexport class InvalidJWTError extends OIDCClientError {\n  constructor(details: string) {\n    super(details)\n    this.name = \"InvalidJWTError\"\n    this.error_description = details\n  }\n}\n\nexport class InvalidIdTokenError extends InvalidJWTError {\n  constructor(details: string) {\n    super(details)\n    this.name = \"InvalidIdTokenError\"\n  }\n}\n\nexport class InteractionCancelled extends OIDCClientError {\n  constructor(details: string) {\n    super(details)\n    this.name = \"InteractionCancelled\"\n  }\n}\n","export type Listener = (...args: any) => void\n\nexport class EventEmitter<T extends string> {\n  callbacks: Record<string, any[]>\n\n  constructor() {\n    this.callbacks = {}\n  }\n\n  once(event: T, fn: (...args: any[]) => void) {\n    function on(this: EventEmitter<any>, ...onArgs: any[]) {\n      this.off(event, on)\n      fn.apply(this, onArgs)\n    }\n    on.fn = fn\n    this.on(event, on)\n    return this\n  }\n\n  on(event: T, cb: (...args: any[]) => void) {\n    if (!this.callbacks[`$${event}`]) this.callbacks[`$${event}`] = []\n    this.callbacks[`$${event}`].push(cb)\n    return this\n  }\n\n  off(event?: T, fn?: (...args: any[]) => void) {\n    if (!event) {\n      this.callbacks = {}\n      return this\n    }\n\n    // specific event\n    const callbacks = this.callbacks[`$${event}`]\n    if (!callbacks) return this\n\n    // remove all handlers\n    if (!fn) {\n      delete this.callbacks[`$${event}`]\n      return this\n    }\n\n    for (let i = 0; i < callbacks.length; i++) {\n      const cb = callbacks[i]\n      if (cb === fn || cb.fn === fn) {\n        callbacks.splice(i, 1)\n        break\n      }\n    }\n\n    // Remove event specific arrays for event types that no\n    // one is subscribed for to avoid memory leak.\n    if (callbacks.length === 0) {\n      delete this.callbacks[`$${event}`]\n    }\n\n    return this\n  }\n\n  emit(event: T, ...args: any[]) {\n    let cbs = this.callbacks[`$${event}`]\n    if (cbs) {\n      cbs = cbs.slice(0)\n      for (let i = 0, len = cbs.length; i < len; ++i) {\n        cbs[i].apply(this, args)\n      }\n    }\n    return this\n  }\n}\n","export interface StateStore<T = Record<string, any>> {\n  init?(): Promise<StateStore<T>>\n}\n\nexport abstract class StateStore<T = Record<string, any>> {\n  prefix: string\n\n  constructor(prefix = \"\") {\n    this.prefix = prefix\n  }\n\n  public abstract get(key: string): Promise<T | null>\n\n  public abstract set(key: string, value: T): Promise<void>\n\n  public abstract del(key: string): Promise<void>\n\n  public abstract clear(maxAge?: number): Promise<void>\n}\n","import { StateStore } from \"./state_store\"\n\nexport class InMemoryStateStore<T = any> extends StateStore<T> {\n  map = new Map()\n\n  clear(before?: number) {\n    if (before) {\n      this.map.forEach((val, ind) => {\n        if (val.created_at < before) {\n          this.map.delete(ind)\n        }\n      })\n      return Promise.resolve()\n    }\n    return Promise.resolve(this.map.clear())\n  }\n\n  del(key: string) {\n    this.map.delete(key)\n    return Promise.resolve()\n  }\n\n  get(key: string) {\n    return Promise.resolve(this.map.get(key) || null)\n  }\n\n  set(key: string, value: any) {\n    this.map.set(key, value)\n    return Promise.resolve()\n  }\n}\n","import { StateStore } from \"./state_store\"\n\nexport class LocalStorageStateStore<T = any> extends StateStore<T> {\n  constructor(prefix = \"pa_oidc.\") {\n    super(prefix)\n  }\n\n  get(key: string) {\n    return new Promise<T | null>((resolve) => {\n      const value = window.localStorage.getItem(this.prefix + key)\n      if (value) {\n        resolve(JSON.parse(value))\n      } else {\n        resolve(null)\n      }\n    })\n  }\n\n  set(key: string, value: T) {\n    return new Promise<void>((resolve) => {\n      window.localStorage.setItem(this.prefix + key, JSON.stringify(value))\n      resolve()\n    })\n  }\n\n  del(key: string) {\n    return new Promise<void>((resolve) => {\n      window.localStorage.removeItem(this.prefix + key)\n      resolve()\n    })\n  }\n\n  clear(before?: number): Promise<void> {\n    return new Promise<void>((resolve) => {\n      let i\n      const storedKeys: string[] = []\n      for (i = 0; i < window.localStorage.length; i++) {\n        const key = window.localStorage.key(i)\n        // items only created by oidc client\n        if (key?.substring(0, this.prefix.length) === this.prefix) {\n          storedKeys.push(key)\n        }\n      }\n      for (i = 0; i < storedKeys.length; i++) {\n        if (before) {\n          try {\n            const storedItem = JSON.parse(window.localStorage.getItem(storedKeys[i])!)\n            if (storedItem.created_at < before) {\n              window.localStorage.removeItem(storedKeys[i])\n            }\n          } catch {}\n        } else {\n          window.localStorage.removeItem(storedKeys[i])\n        }\n      }\n      resolve()\n    })\n  }\n}\n","export class Timer {\n  private now: () => number\n\n  private _timerHandle: any\n\n  private _expiration!: number\n\n  constructor(currentTimeInMillisFunc = () => Date.now()) {\n    this.now = currentTimeInMillisFunc\n  }\n\n  start(duration: number, callback: () => void) {\n    if (duration <= 0) {\n      duration = 1\n    }\n    const expiration = this.now() / 1000 + duration\n    if (this._expiration === expiration && this._timerHandle) {\n      return\n    }\n\n    this.stop()\n\n    this._expiration = expiration\n\n    // prevent device sleep and delayed timers\n    let timerDuration = 5\n    if (duration < timerDuration) {\n      timerDuration = duration\n    }\n    this._timerHandle = setInterval(() => {\n      if (this._expiration <= this.now() / 1000) {\n        this.stop()\n        callback()\n      }\n    }, timerDuration * 1000)\n  }\n\n  stop() {\n    if (this._timerHandle) {\n      clearInterval(this._timerHandle)\n      this._timerHandle = null\n    }\n  }\n}\n","import { AuthenticationError, OIDCClientError } from \"../errors\"\nimport type { IFrameOptions } from \"../interfaces\"\n\n/**\n * Default HTML attributes applied to every hidden iframe created by\n * {@link createHiddenFrame} and used internally by {@link runIframe}.\n *\n * These attributes control accessibility and identification of the iframe\n * used during silent authentication and session-related operations.\n *\n * ## Customization\n * This object is **intentionally mutable** and acts as a global extension point.\n * Applications may modify or extend the attributes to adjust how the iframe is\n * renderedâ€”for example, to add monitoring hooks, test selectors, or custom\n * accessibility attributes.\n *\n * Modifications must be applied **before** any iframe-related `OIDCClient`\n * methods are called (such as {@link OIDCClient.silentLogin}), because each\n * iframe is created using a snapshot of `DefaultIframeAttributes` at creation time.\n *\n * ### Example: Adding a custom attribute\n *\n * ```ts\n * import { DefaultIframeAttributes, OIDCClient } from \"@plusauth/oidc-client-js\";\n *\n * // Add a custom data attribute to all future hidden iframes\n * DefaultIframeAttributes[\"data-myapp\"] = \"example\";\n *\n * const oidc = new OIDCClient({ ... });\n * await oidc.silentLogin();\n *\n * // The silent login iframe now includes: <iframe data-myapp=\"example\" ...>\n * ```\n *\n * Typical use cases include:\n *  - Adding `data-*` attributes for debugging or testing\n *  - Adding custom accessibility metadata\n *  - Integrating with CSP / monitoring tools requiring tagged iframe elements\n *\n * @see createHiddenFrame\n * @see runIframe\n */\nexport const DefaultIframeAttributes = {\n  title: \"__pa_helper__hidden\",\n  \"aria-hidden\": \"true\",\n} as Record<string, string>\n\nexport function createHiddenFrame() {\n  const iframe = window.document.createElement(\"iframe\")\n  iframe.style.width = \"0\"\n  iframe.style.height = \"0\"\n  iframe.style.position = \"absolute\"\n  iframe.style.visibility = \"hidden\"\n  iframe.style.display = \"none\"\n\n  for (const [key, value] of Object.entries(DefaultIframeAttributes)) {\n    iframe.setAttribute(key, value)\n  }\n\n  return iframe\n}\n\nexport function runIframe(url: string, options: IFrameOptions) {\n  return new Promise<any>((resolve, reject) => {\n    let onLoadTimeoutId: any = null\n    const timeoutMs = (options.timeout || 10) * 1000\n    const iframe = createHiddenFrame()\n\n    const timeoutSetTimeoutId = setTimeout(() => {\n      reject(new OIDCClientError(\"Timed out\"))\n      removeIframe()\n    }, timeoutMs)\n\n    const iframeEventHandler = (e: MessageEvent) => {\n      if (e.origin !== options.eventOrigin) return\n      if (!e.data || e.data.type !== \"authorization_response\") return\n      const eventSource = e.source\n      if (eventSource) {\n        ;(<any>eventSource).close()\n      }\n\n      const resp = e.data.response || e.data\n      resp.error\n        ? reject(\n            new AuthenticationError(resp.error, resp.error_description, resp.state, resp.error_uri),\n          )\n        : resolve(e.data)\n      clearTimeout(timeoutSetTimeoutId)\n      removeIframe()\n    }\n\n    const removeIframe = () => {\n      if (onLoadTimeoutId != null) {\n        clearTimeout(onLoadTimeoutId)\n      }\n      if (window.document.body.contains(iframe)) {\n        window.document.body.removeChild(iframe)\n      }\n      window.removeEventListener(\"message\", iframeEventHandler, false)\n    }\n\n    const onLoadTimeout = () =>\n      setTimeout(() => {\n        reject(new OIDCClientError(\"Could not complete silent authentication\", url))\n        removeIframe()\n      }, timeoutMs)\n\n    window.addEventListener(\"message\", iframeEventHandler, false)\n    window.document.body.appendChild(iframe)\n    iframe.setAttribute(\"src\", url)\n\n    /**\n     * In case of wrong client id, wrong redirect_uri, in short when redirect did not happen\n     * we assume flow failed.\n     */\n    iframe.onload = () => {\n      onLoadTimeoutId = onLoadTimeout()\n    }\n  })\n}\n","import type { SessionChecker, SessionCheckerOptions } from \"../interfaces\"\n\nimport { createHiddenFrame } from \"./iframe\"\n\nconst DEFAULT_CHECK_INTERVAL = 2000\n\nexport function createSessionCheckerFrame(options: SessionCheckerOptions): SessionChecker {\n  const { url, callback, client_id, checkInterval } = options\n  let internalSessionState: string | null\n  const idx = url.indexOf(\"/\", url.indexOf(\"//\") + 2)\n  const frameOrigin = url.substr(0, idx)\n\n  const frame = createHiddenFrame()\n\n  let timer: any\n\n  const load = () => {\n    return new Promise((resolve) => {\n      window.document.body.appendChild(frame)\n      window.addEventListener(\"message\", iframeEventHandler, false)\n      frame.onload = () => {\n        resolve(null)\n      }\n    })\n  }\n\n  const start = (sessionState: string) => {\n    load().then(() => {\n      if (sessionState && internalSessionState !== sessionState) {\n        stop()\n        internalSessionState = sessionState\n        const send = () => {\n          frame.contentWindow!.postMessage(`${client_id} ${internalSessionState}`, frameOrigin)\n        }\n        send()\n        timer = window.setInterval(send, checkInterval || DEFAULT_CHECK_INTERVAL)\n      }\n    })\n  }\n\n  const stop = () => {\n    internalSessionState = null\n    if (timer) {\n      window.clearInterval(timer)\n      timer = null\n    }\n  }\n\n  const iframeEventHandler = (e: MessageEvent) => {\n    if (e.origin === frameOrigin && e.source === frame.contentWindow) {\n      if (e.data === \"error\") {\n        stop()\n        callback(e.data)\n      } else if (e.data === \"changed\") {\n        stop()\n        callback()\n      }\n    }\n  }\n\n  frame.setAttribute(\"src\", url)\n\n  return {\n    stop,\n    start,\n  }\n}\n","import { fromByteArray } from \"base64-js\"\n\nexport function isValidIssuer(issuer: string) {\n  try {\n    const url = new URL(issuer)\n    if (![\"http:\", \"https:\"].includes(url.protocol)) {\n      return false\n    }\n    if (url.search !== \"\" || url.hash !== \"\") {\n      return false\n    }\n    return true\n  } catch {\n    return false\n  }\n}\nexport function buildEncodedQueryString(obj?: Record<string, any>, appendable = true) {\n  if (!obj) return \"\"\n  const ret: string[] = []\n  for (const d in obj) {\n    if (obj.hasOwnProperty(d) && obj[d]) {\n      ret.push(\n        `${encodeURIComponent(d)}=${encodeURIComponent(\n          typeof obj[d] === \"object\" ? JSON.stringify(obj[d]) : obj[d]!,\n        )}`,\n      )\n    }\n  }\n  return `${appendable ? \"?\" : \"\"}${ret.join(\"&\")}`\n}\n\nexport function parseQueryUrl(value: string) {\n  const result: Record<string, string> = {}\n  value = value.trim().replace(/^(\\?|#|&)/, \"\")\n  const params = value.split(\"&\")\n  for (let i = 0; i < params.length; i += 1) {\n    const paramAndValue = params[i]\n    const parts = paramAndValue.split(\"=\")\n    const key = decodeURIComponent(parts.shift()!)\n    const value = parts.length > 0 ? parts.join(\"=\") : \"\"\n    result[key] = decodeURIComponent(value)\n  }\n  return result\n}\n\nexport function urlSafe(data: Uint8Array | string): string {\n  const encoded = typeof data === \"string\" ? data : fromByteArray(new Uint8Array(data))\n  return encoded.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\")\n}\n","import { urlSafe } from \"./url\"\n\nexport async function sha256(str: string) {\n  if (typeof window.crypto !== \"undefined\" && \"subtle\" in window.crypto) {\n    const buffer = await window.crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode(str))\n    return urlSafe(new Uint8Array(buffer))\n  }\n  return urlSafe(_sha256(str)!)\n}\n\n/**\n * Generate sha-256 hash of a string.\n *\n * @link https://geraintluff.github.io/sha256/\n *\n * @param data data to generate hash of\n * @param base64 By default the returned value is base64 encoded. If `false` format will be hex.\n */\nfunction _sha256(data: string, base64 = true) {\n  function rightRotate(value: number, amount: number) {\n    return (value >>> amount) | (value << (32 - amount))\n  }\n\n  const mathPow = Math.pow\n  const maxWord = mathPow(2, 32)\n  const lengthProperty = \"length\"\n  let i\n  let j\n  let result = \"\"\n\n  const words = [] as number[]\n  const asciiBitLength = data[lengthProperty] * 8\n\n  // @ts-expect-error\n  let hash = (sha256.h = sha256.h || [])\n  // @ts-expect-error\n  const k = (sha256.k = sha256.k || [])\n  let primeCounter = k[lengthProperty]\n  const isComposite = {} as Record<number, number>\n  for (let candidate = 2; primeCounter < 64; candidate++) {\n    if (!isComposite[candidate]) {\n      for (i = 0; i < 313; i += candidate) {\n        isComposite[i] = candidate\n      }\n      hash[primeCounter] = (mathPow(candidate, 0.5) * maxWord) | 0\n      k[primeCounter++] = (mathPow(candidate, 1 / 3) * maxWord) | 0\n    }\n  }\n  data += \"\\x80\" // Append ?' bit (plus zero padding)\n  while ((data[lengthProperty] % 64) - 56) data += \"\\x00\" // More zero padding\n  for (i = 0; i < data[lengthProperty]; i++) {\n    j = data.charCodeAt(i)\n    if (j >> 8) return // ASCII check: only accept characters in range 0-255\n    words[i >> 2] |= j << (((3 - i) % 4) * 8)\n  }\n  words[words[lengthProperty]] = (asciiBitLength / maxWord) | 0\n  words[words[lengthProperty]] = asciiBitLength\n\n  for (j = 0; j < words[lengthProperty]; ) {\n    const w = words.slice(j, (j += 16))\n    const oldHash = hash\n    hash = hash.slice(0, 8)\n\n    for (i = 0; i < 64; i++) {\n      const w15 = w[i - 15]\n      const w2 = w[i - 2]\n      const a = hash[0]\n      const e = hash[4]\n      const temp1 =\n        hash[7] +\n        (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) + // S1\n        ((e & hash[5]) ^ (~e & hash[6])) + // ch\n        k[i] +\n        (w[i] =\n          i < 16\n            ? w[i]\n            : (w[i - 16] +\n                (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15 >>> 3)) + // s0\n                w[i - 7] +\n                (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2 >>> 10))) | // s1\n              0)\n      const temp2 =\n        (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) + // S0\n        ((a & hash[1]) ^ (a & hash[2]) ^ (hash[1] & hash[2])) // maj\n\n      hash = [(temp1 + temp2) | 0].concat(hash)\n      hash[4] = (hash[4] + temp1) | 0\n    }\n\n    for (i = 0; i < 8; i++) {\n      hash[i] = (hash[i] + oldHash[i]) | 0\n    }\n  }\n\n  for (i = 0; i < 8; i++) {\n    for (j = 3; j + 1; j--) {\n      const b = (hash[i] >> (j * 8)) & 255\n      result += (b < 16 ? 0 : \"\") + b.toString(16)\n    }\n  }\n  return base64\n    ? btoa(\n        result\n          .match(/\\w{2}/g)!\n          .map((a) => String.fromCharCode(Number.parseInt(a, 16)))\n          .join(\"\"),\n      )\n    : result\n}\n","import { InvalidIdTokenError, InvalidJWTError, OIDCClientError } from \"../errors\"\nimport type { IPlusAuthClientOptions, JWTValidationOptions, ParsedJWT } from \"../interfaces\"\nimport { sha256 } from \"./crypto\"\n\nconst CHARSET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n\nfunction getRandomBytes(n: number) {\n  // @ts-expect-error\n  const crypto = self.crypto || self.msCrypto\n  const QUOTA = 65536\n  const a = new Uint8Array(n)\n  for (let i = 0; i < n; i += QUOTA) {\n    crypto.getRandomValues(a.subarray(i, i + Math.min(n - i, QUOTA)))\n  }\n  return a\n}\n\nexport function generateRandom(length: number) {\n  let out = \"\"\n  const charsLen = CHARSET.length\n  const maxByte = 256 - (256 % charsLen)\n  while (length > 0) {\n    const buf = getRandomBytes(Math.ceil((length * 256) / maxByte))\n    for (let i = 0; i < buf.length && length > 0; i++) {\n      const randomByte = buf[i]\n      if (randomByte < maxByte) {\n        out += CHARSET.charAt(randomByte % charsLen)\n        length--\n      }\n    }\n  }\n  return out\n}\n\nexport async function deriveChallenge(code: string): Promise<string> {\n  if (code.length < 43 || code.length > 128) {\n    return Promise.reject(new OIDCClientError(`Invalid code length: ${code.length}`))\n  }\n  return await sha256(code)\n}\n// https://datatracker.ietf.org/doc/html/rfc4648#section-5\nexport const urlDecodeB64 = (input: string) =>\n  decodeURIComponent(\n    atob(input.replace(/_/g, \"/\").replace(/-/g, \"+\"))\n      .split(\"\")\n      .map((c) => {\n        return `%${`00${c.charCodeAt(0).toString(16)}`.slice(-2)}`\n      })\n      .join(\"\"),\n  )\n\nexport function parseJwt(jwt: string): ParsedJWT {\n  try {\n    const parts = jwt.split(\".\")\n    if (parts.length !== 3) {\n      throw new Error(\"Wrong JWT format\")\n    }\n    return {\n      header: JSON.parse(urlDecodeB64(parts[0])),\n      payload: JSON.parse(urlDecodeB64(parts[1])),\n    }\n  } catch {\n    throw new InvalidJWTError(\"Failed to parse jwt\")\n  }\n}\n\nexport function validateIdToken(id_token: string, nonce: string, options: IPlusAuthClientOptions) {\n  if (!nonce) {\n    throw new OIDCClientError(\"No nonce on state\")\n  }\n\n  try {\n    const jwt = parseJwt(id_token)\n\n    if (nonce !== jwt.payload.nonce) {\n      throw new Error(`Invalid nonce in id_token: ${jwt.payload.nonce}`)\n    }\n\n    validateJwt(id_token, options, true)\n\n    // @ts-expect-error\n    if (!jwt.payload.sub) {\n      throw new Error(\"No Subject (sub) present in id_token\")\n    }\n\n    return jwt.payload\n  } catch (e) {\n    throw new InvalidIdTokenError(e.message)\n  }\n}\n\nexport function validateJwt(jwt: string, options: JWTValidationOptions, isIdToken = false) {\n  // eslint-disable-next-line prefer-const\n  let { clockSkew, currentTimeInMillis, issuer, audience, client_id } = options\n  if (!clockSkew) {\n    clockSkew = 0\n  }\n  const now = (currentTimeInMillis?.() || Date.now()) / 1000\n\n  const payload = parseJwt(jwt).payload\n\n  if (!payload.iss) {\n    throw new InvalidJWTError(\"Issuer (iss) was not provided\")\n  }\n  if (payload.iss !== issuer) {\n    throw new InvalidJWTError(`Invalid Issuer (iss) in token: ${payload.iss}`)\n  }\n\n  if (!payload.aud) {\n    throw new InvalidJWTError(\"Audience (aud) was not provided\")\n  }\n\n  // Audience must be equal to client_id in id_token\n  // https://openid.net/specs/openid-connect-core-1_0.html#IDToken\n  if (\n    Array.isArray(payload.aud)\n      ? payload.aud.indexOf(isIdToken ? client_id : audience || client_id) === -1\n      : payload.aud !== (isIdToken ? client_id : audience || client_id)\n  ) {\n    throw new InvalidJWTError(`Invalid Audience (aud) in token: ${payload.aud}`)\n  }\n\n  if (payload.azp && payload.azp !== client_id) {\n    throw new InvalidJWTError(`Invalid Authorized Party (azp) in token: ${payload.azp}`)\n  }\n\n  const lowerNow = Math.ceil(now + clockSkew)\n  const upperNow = Math.floor(now - clockSkew)\n\n  if (!payload.iat) {\n    throw new InvalidJWTError(\"Issued At (iat) was not provided\")\n  }\n\n  if (lowerNow < Number(payload.iat)) {\n    throw new InvalidJWTError(`Issued At (iat) is in the future: ${payload.iat}`)\n  }\n\n  if (payload.nbf && lowerNow < Number(payload.nbf)) {\n    throw new InvalidJWTError(`Not Before time (nbf) is in the future: ${payload.nbf}`)\n  }\n\n  if (!payload.exp) {\n    throw new InvalidJWTError(\"Expiration Time (exp) was not provided\")\n  }\n  if (Number(payload.exp) < upperNow) {\n    throw new InvalidJWTError(`Expiration Time (exp) is in the past: ${payload.exp}`)\n  }\n\n  return payload\n}\n\n// Retrieved from https://www.iana.org/assignments/jwt/jwt.xhtml\nexport const nonUserClaims = [\n  \"iss\",\n  // 'sub',\n  \"aud\",\n  \"exp\",\n  \"nbf\",\n  \"iat\",\n  \"jti\",\n  \"azp\",\n  \"nonce\",\n  \"auth_time\",\n  \"at_hash\",\n  \"c_hash\",\n  \"acr\",\n  \"amr\",\n  \"sub_jwk\",\n  \"cnf\",\n  \"sip_from_tag\",\n  \"sip_date\",\n  \"sip_callid\",\n  \"sip_cseq_num\",\n  \"sip_via_branch\",\n  \"orig\",\n  \"dest\",\n  \"mky\",\n  \"events\",\n  \"toe\",\n  \"txn\",\n  \"rph\",\n  \"sid\",\n  \"vot\",\n  \"vtm\",\n  \"attest\",\n  \"origid\",\n  \"act\",\n  \"scope\",\n  \"client_id\",\n  \"may_act\",\n  \"jcard\",\n  \"at_use_nbr\",\n] as const\n","import { buildEncodedQueryString } from \"./url\"\n\nexport interface RequestOptions {\n  body?: Record<string, string | number | null | undefined>\n  headers?: Record<string, string>\n  method: \"GET\" | \"POST\" | \"PATCH\" | \"TRACE\" | \"OPTIONS\" | \"HEAD\"\n  requestType?: \"form\" | \"json\"\n  url: string\n}\n\nexport function request(options: RequestOptions): Promise<any> {\n  let body: any = null\n  let headers = options.headers || {}\n  if (options.method === \"POST\") {\n    headers = {\n      \"Content-Type\":\n        options.requestType === \"form\"\n          ? \"application/x-www-form-urlencoded;charset=UTF-8\"\n          : \"application/json;charset=UTF-8\",\n      ...headers,\n    }\n  }\n  if (options.body) {\n    body =\n      options.requestType === \"form\"\n        ? buildEncodedQueryString(options.body, false)\n        : JSON.stringify(options.body)\n  }\n\n  return new Promise((resolve, reject) => {\n    fetch(options.url, {\n      method: options.method,\n      body: body,\n      headers,\n    })\n      .then((value: Response) => resolve(value.json()))\n      .catch(reject)\n  })\n}\n","type RequiredAndNotNull<T> = {\n  [P in keyof T]-?: Exclude<T[P], undefined>\n}\n\n/**\n * not suitable for every object but it is enough for this library\n * @param object\n */\nexport function cleanUndefined<T extends Record<string, any>>(object: T) {\n  return JSON.parse(JSON.stringify(object)) as RequiredAndNotNull<T>\n}\n\nfunction merge(previousValue: any, currentValue: any) {\n  for (const p in currentValue) {\n    if (currentValue[p] !== undefined) {\n      if (typeof currentValue[p] === \"object\" && currentValue[p].constructor.name === \"Object\") {\n        previousValue[p] = merge(previousValue[p] || {}, currentValue[p])\n      } else {\n        previousValue[p] = currentValue[p]\n      }\n    }\n  }\n  return previousValue\n}\nexport function mergeObjects<T extends object, U>(obj1: T, obj2: U): RequiredAndNotNull<T & U>\nexport function mergeObjects<T extends object, U, K>(\n  obj1: T,\n  obj2: U,\n  obj3: K,\n): RequiredAndNotNull<T & U & K>\nexport function mergeObjects(...objects: any[]) {\n  return objects.reduce((previousValue, currentValue) => {\n    return merge(previousValue || {}, currentValue)\n  }, {}) as any\n}\n","export const isResponseType = (type: string, response_type?: string) =>\n  response_type && response_type.split(/\\s+/g).filter((rt) => rt === type).length > 0\n\nexport const isScopeIncluded = (scope: string, scopes?: string) =>\n  scopes && scopes.split(\" \").indexOf(scope) > -1\n","import { InteractionCancelled, OIDCClientError } from \"../errors\"\nimport type { PopupOptions } from \"../interfaces\"\n\nconst openPopup = (url: string, width = 400, height = 600) => {\n  const left = window.screenX + (window.innerWidth - width) / 2\n  const top = window.screenY + (window.innerHeight - height) / 2\n\n  return window.open(\n    url,\n    \"oidc-login-popup\",\n    `left=${left},top=${top},width=${width},height=${height},resizable,scrollbars=yes,status=1`,\n  )\n}\n\nexport function runPopup(url: string, options: PopupOptions) {\n  let popup = options.popup\n\n  if (popup) {\n    popup.location.href = url\n  } else {\n    popup = openPopup(url)\n  }\n\n  if (!popup) {\n    /* istanbul ignore next */\n    throw new Error(\"Could not open popup\")\n  }\n\n  let timeoutId: any\n  let closeId: any\n\n  return new Promise<{ response: any; state: string }>((resolve, reject) => {\n    function clearHandlers() {\n      clearInterval(closeId)\n      clearTimeout(timeoutId)\n      window.removeEventListener(\"message\", messageListener)\n    }\n\n    const timeoutMs = (options.timeout || 60) * 1000\n    timeoutId = setTimeout(() => {\n      clearHandlers()\n      reject(new OIDCClientError(\"Timed out\"))\n    }, timeoutMs)\n\n    closeId = setInterval(() => {\n      if (popup!.closed) {\n        clearHandlers()\n        reject(new InteractionCancelled(\"user closed popup\"))\n      }\n    }, timeoutMs)\n\n    window.addEventListener(\"message\", messageListener)\n\n    function messageListener(e: MessageEvent) {\n      if (!e.data || e.data.type !== \"authorization_response\") return\n      clearHandlers()\n      popup!.close()\n      const data = e.data.response || e.data\n      data.error ? reject(new OIDCClientError(data.error, data.error_description)) : resolve(e.data)\n    }\n  })\n}\n","/*\nJitbit TabUtils - helper for multiple browser tabs. version 1.0\nhttps://github.com/jitbit/TabUtils\n- executing \"interlocked\" function call - only once per multiple tabs\n- broadcasting a message to all tabs (including the current one) with some message \"data\"\n- handling a broadcasted message\nMIT license: https://github.com/jitbit/TabUtils/blob/master/LICENSE\n*/\n\nimport type { EventEmitter } from \"../helpers\"\n\nconst currentTabId = `${performance.now()}:${(Math.random() * 1000000000) | 0}`\nconst handlers: Record<string, any> = {}\n\nexport class TabUtils {\n  keyPrefix: string\n\n  private events: EventEmitter<any>\n\n  constructor(kid: string, fallbackEvents: EventEmitter<any>) {\n    this.keyPrefix = kid\n    this.events = fallbackEvents\n  }\n\n  //runs code only once in multiple tabs\n  //the lock holds for 4 seconds (in case the function is async and returns right away, for example, an ajax call intiated)\n  //then it is cleared\n  CallOnce(lockname: string, fn: () => void, timeout = 3000): void {\n    if (!lockname) throw \"empty lockname\"\n\n    if (!window.localStorage) {\n      //no local storage. old browser. screw it, just run the function\n      fn()\n      return\n    }\n\n    const localStorageKey = this.keyPrefix + lockname\n\n    localStorage.setItem(localStorageKey, currentTabId)\n    //re-read after a delay (after all tabs have saved their tabIDs into ls)\n    setTimeout(() => {\n      if (localStorage.getItem(localStorageKey) === currentTabId) fn()\n    }, 150)\n\n    //cleanup - release the lock after 3 seconds and on window unload (just in case user closed the window while the lock is still held)\n    setTimeout(() => {\n      localStorage.removeItem(localStorageKey)\n    }, timeout)\n  }\n\n  BroadcastMessageToAllTabs(messageId: string, eventData: any): void {\n    //now we also need to manually execute handler in the current tab too, because current tab does not get 'storage' events\n    try {\n      handlers[messageId](eventData)\n    } catch {}\n\n    if (!window.localStorage) {\n      this.events.emit(messageId, eventData)\n      return //no local storage. old browser\n    }\n\n    const data = {\n      data: eventData,\n      timeStamp: Date.now(),\n    } //add timestamp because overwriting same data does not trigger the event\n\n    //this triggers 'storage' event for all other tabs except the current tab\n    localStorage.setItem(`${this.keyPrefix}event${messageId}`, JSON.stringify(data))\n\n    //cleanup\n    setTimeout(() => {\n      localStorage.removeItem(`${this.keyPrefix}event${messageId}`)\n    }, 3000)\n  }\n\n  OnBroadcastMessage(messageId: string, fn: (data: any) => void): void {\n    handlers[messageId] = fn\n    if (!window.localStorage) {\n      this.events.on(messageId, fn)\n      return //no local storage. old browser\n    }\n\n    //first register a handler for \"storage\" event that we trigger above\n    window.addEventListener(\"storage\", (ev) => {\n      if (ev.key !== `${this.keyPrefix}event${messageId}`) return // ignore other keys\n      if (!ev.newValue) return //called by cleanup?\n      const messageData = JSON.parse(ev.newValue)\n      fn(messageData.data)\n    })\n  }\n}\n","import type { EventTypes } from \"./constants\"\nimport { Events } from \"./constants\"\n\nimport { AuthenticationError, InvalidIdTokenError, OIDCClientError, StateNotFound } from \"./errors\"\n\nimport type { StateStore } from \"./helpers\"\nimport { EventEmitter, InMemoryStateStore, LocalStorageStateStore } from \"./helpers\"\n\nimport { Timer } from \"./helpers/timer\"\nimport type {\n  AuthRecord,\n  AuthRequestOptions,\n  IEndpointConfiguration,\n  IPlusAuthClientOptions,\n  LogoutRequestOptions,\n  PopupOptions,\n  RevokeOptions,\n  SessionChecker,\n  SessionMonitorOptions,\n  StateRecord,\n  TokenRequestOption,\n  TokenResponse,\n  TokenType,\n} from \"./interfaces\"\n\nimport type { RequestOptions } from \"./utils\"\nimport {\n  buildEncodedQueryString,\n  createSessionCheckerFrame,\n  deriveChallenge,\n  generateRandom,\n  isValidIssuer,\n  nonUserClaims,\n  parseQueryUrl,\n  request,\n  runIframe,\n  validateIdToken,\n} from \"./utils\"\nimport { cleanUndefined, mergeObjects } from \"./utils/object\"\n\nimport { isResponseType, isScopeIncluded } from \"./utils/oidc\"\nimport { runPopup } from \"./utils/popup\"\nimport { TabUtils } from \"./utils/tab_utils\"\n\n/**\n * `OIDCClient` provides methods for interacting with OIDC/OAuth2 authorization server. Those methods are signing a\n * user in, signing out, managing the user's claims, checking session and managing tokens returned from the\n * OIDC/OAuth2 provider.\n *\n */\nexport class OIDCClient extends EventEmitter<EventTypes> {\n  options: IPlusAuthClientOptions\n\n  user?: any\n\n  scopes?: string[]\n\n  accessToken?: string\n\n  refreshToken?: string\n\n  idToken?: string\n\n  idTokenRaw?: string\n\n  issuer_metadata?: Record<string, any>\n\n  private readonly http: (options: RequestOptions) => Promise<any> | never\n\n  private synchronizer: TabUtils\n\n  private stateStore: StateStore<StateRecord>\n\n  private authStore: StateStore<AuthRecord>\n\n  private sessionCheckerFrame?: SessionChecker\n\n  private _accessTokenExpireTimer?: Timer\n\n  private initialized!: boolean\n\n  private __initializePromise!: Promise<any> | undefined\n\n  constructor(options: IPlusAuthClientOptions) {\n    super()\n    if (!isValidIssuer(options.issuer)) {\n      throw new OIDCClientError('\"issuer\" must be a valid uri.')\n    }\n\n    this.synchronizer = new TabUtils(btoa(options.issuer), this)\n\n    this.options = mergeObjects(\n      {\n        secondsToRefreshAccessTokenBeforeExp: 60,\n        autoSilentRenew: true,\n        checkSession: true,\n        stateLength: 10,\n        nonceLength: 10,\n      },\n      options,\n      {\n        // remove last slash for consistency across the lib\n        issuer: options.issuer.endsWith(\"/\") ? options.issuer.slice(0, -1) : options.issuer,\n      },\n    )\n\n    this.http = this.options.httpClient || request\n    this.stateStore =\n      this.options.stateStore || new LocalStorageStateStore<StateRecord>(\"pa_oidc.state.\")\n    this.authStore = this.options.authStore || new InMemoryStateStore<AuthRecord>()\n\n    if (this.options.autoSilentRenew) {\n      this._accessTokenExpireTimer = new Timer()\n    }\n\n    this.on(Events.USER_LOGOUT, async () => {\n      this.user = undefined\n      this.scopes = undefined\n      this.accessToken = undefined\n      this.idToken = undefined\n      this.refreshToken = undefined\n      await this.authStore.clear()\n    })\n\n    this.synchronizer.OnBroadcastMessage(Events.USER_LOGIN, this.onUserLogin.bind(this))\n  }\n\n  /**\n   * Initialize the library with this method. It resolves issuer configuration, jwks keys which are necessary for\n   * validating tokens returned from provider and checking if a user is already authenticated in provider.\n   *\n   * @param checkLogin Make this `false` if you don't want to check user authorization status in provider while\n   * initializing. Defaults to `true`\n   */\n  async initialize(checkLogin = true): Promise<OIDCClient> | never {\n    if (this.initialized) {\n      return this\n    }\n\n    if (this.__initializePromise) {\n      return this.__initializePromise\n    }\n    this.__initializePromise = new Promise(async (resolve, reject) => {\n      try {\n        if (this.stateStore.init) {\n          await this.stateStore.init()\n        }\n        if (this.authStore.init) {\n          await this.authStore.init()\n        }\n\n        if (!this.options.endpoints || Object.keys(this.options.endpoints).length === 0) {\n          await this.fetchFromIssuer()\n        }\n        this.initialized = true\n\n        if (checkLogin) {\n          try {\n            if (!window?.frameElement) {\n              await this.silentLogin()\n            }\n          } catch (e) {\n            this.emit(Events.SILENT_RENEW_ERROR, e)\n            await this.authStore.clear()\n          }\n        } else {\n          const localAuth = await this.authStore.get(\"auth\")\n          if (localAuth) {\n            await this.onUserLogin(localAuth, true)\n          }\n        }\n        resolve(this)\n      } catch (e) {\n        if (e instanceof OIDCClientError) {\n          reject(e)\n        } else {\n          reject(new OIDCClientError(e.message))\n        }\n      } finally {\n        this.__initializePromise = undefined\n      }\n    })\n\n    return this.__initializePromise\n  }\n\n  /**\n   * Redirect to provider's authorization endpoint using provided parameters. You can override any parameter defined\n   * in `OIDCClient`. If you don't provide `state`, `nonce` or `code_verifier` they will be generated automatically\n   * in a random and secure way.\n   *\n   * @param options\n   * @param localState\n   */\n  async login(options: Partial<AuthRequestOptions> = {}, localState: Record<string, any> = {}) {\n    window.location.assign(await this.createAuthRequest(options, localState))\n  }\n\n  /**\n   * Open a popup with the provider's authorization endpoint using provided parameters. You can override any\n   * parameter defined in `OIDCClient`. If you don't provide `state`, `nonce` or `code_verifier` they will be\n   * generated automatically in a random and secure way. You can also override popup options.\n   *\n   * NOTE: Most browsers block popups if they are not happened as a result of user actions. In order to display\n   * login popup you must call this method in an event handler listening for a user action like button click.\n   *\n   * @param options\n   * @param popupOptions\n   */\n  async loginWithPopup(options: Partial<AuthRequestOptions> = {}, popupOptions: PopupOptions = {}) {\n    const url = await this.createAuthRequest({\n      response_mode: \"fragment\",\n      ...options,\n      display: \"popup\",\n      request_type: \"p\",\n    })\n    const { response, state } = await runPopup(url, popupOptions)\n    const { authParams, localState } =\n      !state || typeof state === \"string\" ? await this.loadState(state || response.state) : state\n    const tokenResult = await this.handleAuthResponse(response, authParams, localState)\n    const authObject = await this.handleTokenResult(\n      tokenResult,\n      authParams,\n      mergeObjects(this.options, authParams),\n    )\n    authObject.session_state = response.session_state\n    this.synchronizer.BroadcastMessageToAllTabs(Events.USER_LOGIN, authObject)\n    return localState\n  }\n\n  /**\n   * After a user successfully authorizes an application, the authorization server will redirect the user back to\n   * the application with either an authorization code or access token in the URL. In the callback page you should\n   * call this method.\n   *\n   * @param url Full url which contains authorization request result parameters. Defaults to `window.location.href`\n   */\n  async loginCallback(url: string = window?.location?.href) {\n    if (!url) {\n      return Promise.reject(new OIDCClientError(\"Url must be passed to handle login redirect\"))\n    }\n    let parsedUrl: URL\n    try {\n      parsedUrl = new URL(url)\n    } catch {\n      return Promise.reject(new OIDCClientError(`Invalid callback url passed: \"${url}\"`))\n    }\n\n    const responseParams = parseQueryUrl(parsedUrl.search || parsedUrl.hash)\n    const rawStoredState = await this.loadState(responseParams.state)\n    const { authParams, localState, request_type } = rawStoredState\n    url = url || window.location.href\n    switch (request_type) {\n      case \"s\":\n        if (window?.frameElement) {\n          if (url) {\n            window.parent.postMessage(\n              {\n                type: \"authorization_response\",\n                response: responseParams,\n                state: rawStoredState,\n              },\n              `${location.protocol}//${location.host}`,\n            )\n          }\n        }\n        return\n      case \"p\":\n        if (window.opener && url) {\n          window.opener.postMessage(\n            {\n              type: \"authorization_response\",\n              response: responseParams,\n              state: rawStoredState,\n            },\n            `${location.protocol}//${location.host}`,\n          )\n        }\n        return\n      default: {\n        if (responseParams.error) {\n          return Promise.reject(\n            new AuthenticationError(responseParams.error, responseParams.error_description),\n          )\n        }\n        const tokenResult = await this.handleAuthResponse(responseParams, authParams, localState)\n        const authObject = await this.handleTokenResult(\n          tokenResult,\n          authParams,\n          mergeObjects(this.options, authParams),\n        )\n        authObject.session_state = responseParams.session_state\n        this.synchronizer.BroadcastMessageToAllTabs(Events.USER_LOGIN, authObject)\n        return localState\n      }\n    }\n  }\n\n  /**\n   * Redirect to provider's `end_session_endpoint` with provided parameters. After logout provider will redirect to\n   * provided `post_logout_redirect_uri` if it provided.\n   * @param options\n   */\n  async logout(options: LogoutRequestOptions = {}) {\n    if (!options.localOnly) {\n      const storedAuth = await this.authStore.get(\"auth\")\n      const id_token_hint = options.id_token_hint || storedAuth?.id_token_raw\n      window.location.assign(\n        await this.createLogoutRequest({\n          ...options,\n          id_token_hint,\n        }),\n      )\n    }\n    await this.authStore.clear()\n  }\n\n  /**\n   * OAuth2 token revocation implementation method. See more at [tools.ietf.org/html/rfc7009](https://tools.ietf.org/html/rfc7009)\n   * @param token Token to be revoked\n   * @param type Passed token's type. It will be used to provide `token_type_hint` parameter.\n   * @param options If necessary override options passed to `OIDCClient` by defining them here.\n   */\n  async revokeToken(token: string, type: TokenType = \"access_token\", options: RevokeOptions = {}) {\n    if (!this.options.endpoints!.revocation_endpoint) {\n      return Promise.reject(new OIDCClientError('\"revocation_endpoint\" doesn\\'t exist'))\n    }\n    const finalOptions = {\n      client_id: options.client_id || this.options.client_id,\n      client_secret: options.client_secret || this.options.client_secret,\n      token_type_hint: type,\n      token: token,\n    }\n\n    return this.http({\n      method: \"POST\",\n      requestType: \"form\",\n      url: this.options.endpoints!.revocation_endpoint,\n      body: finalOptions,\n    })\n  }\n\n  /**\n   * Login without having an interaction. If refresh tokens are used and there is a stored refresh token it will\n   * exchange refresh token to receive new access token. If not it silently makes a request the provider's\n   * authorization endpoint using provided parameters. You can override any parameter defined in `OIDCClient`. If\n   * you don't provide `state`, `nonce` or `code_verifier` they will be generated automatically in a random and\n   * secure way.\n   *\n   * @param options\n   * @param localState\n   */\n  async silentLogin(options: AuthRequestOptions = {}, localState: Record<string, any> = {}) {\n    await this.initialize(false)\n    let tokenResult: any\n    let finalState: any = {}\n\n    const storedAuth = (await this.authStore.get(\"auth\")) || {}\n\n    const finalOptions = mergeObjects(\n      {\n        response_mode: \"query\",\n        display: \"page\",\n        prompt: \"none\",\n      },\n      this.options,\n      options,\n    )\n\n    if (finalOptions.silent_redirect_uri) {\n      finalOptions.redirect_uri = finalOptions.silent_redirect_uri\n    }\n\n    if (this.options.useRefreshToken && storedAuth?.refresh_token) {\n      finalState.authParams = mergeObjects(\n        storedAuth?.authParams || {},\n        finalState.authParams || {},\n      )\n      tokenResult = await this.exchangeRefreshToken({\n        ...finalOptions,\n        refresh_token: storedAuth.refresh_token,\n      })\n    } else {\n      const authUrl = await this.createAuthRequest(\n        {\n          ...finalOptions,\n          request_type: \"s\",\n        },\n        localState,\n      )\n\n      const { response, state } = await runIframe(authUrl, {\n        timeout: finalOptions.silentRequestTimeout,\n        eventOrigin: window.location.origin,\n      })\n      tokenResult = await this.handleAuthResponse(response, finalOptions, localState)\n      storedAuth.session_state = response.session_state\n      finalState = state\n    }\n\n    const authObject = await this.handleTokenResult(\n      tokenResult,\n      finalState.authParams,\n      finalOptions,\n    )\n    authObject.session_state = storedAuth.session_state\n    this.synchronizer.BroadcastMessageToAllTabs(Events.USER_LOGIN, authObject)\n    return finalState.localState\n  }\n\n  /**\n   * Retrieve logged in user's access token if it exists.\n   */\n  async getAccessToken() {\n    return (await this.authStore.get(\"auth\"))?.access_token\n  }\n\n  /**\n   * Retrieve logged in user's refresh token if it exists.\n   */\n  async getRefreshToken() {\n    return (await this.authStore.get(\"auth\"))?.refresh_token\n  }\n\n  /**\n   * Retrieve logged in user's parsed id token if it exists.\n   */\n  async getIdToken() {\n    return (await this.authStore.get(\"auth\"))?.id_token\n  }\n\n  /**\n   * Retrieve access token's expiration.\n   */\n  async getExpiresIn() {\n    return (await this.authStore.get(\"auth\"))?.expires_in\n  }\n\n  /**\n   * Retrieve logged in user's id token in raw format if it exists.\n   */\n  async getIdTokenRaw() {\n    return (await this.authStore.get(\"auth\"))?.id_token_raw\n  }\n\n  /**\n   * Retrieve logged in user's scopes if it exists.\n   */\n  async getScopes() {\n    return (await this.authStore.get(\"auth\"))?.scope?.split(\" \").filter(Boolean)\n  }\n\n  /**\n   * Retrieve logged in user's profile.\n   */\n  async getUser() {\n    return (await this.authStore.get(\"auth\"))?.user\n  }\n\n  /**\n   * If there is a user stored locally return true. Otherwise it will make a silentLogin to check if End-User is\n   * logged in provider.\n   *\n   * @param localOnly Don't check provider\n   */\n  async isLoggedIn(localOnly = false) {\n    const existsOnLocal = !!(await this.getUser())\n    if (!existsOnLocal && !localOnly) {\n      try {\n        await this.silentLogin()\n        return true\n      } catch (_e) {\n        return false\n      }\n    }\n    return existsOnLocal\n  }\n\n  /**\n   * Create authorization request with provided options.\n   *\n   * @param options\n   * @param localState\n   * @private\n   */\n  private async createAuthRequest(\n    options: Partial<AuthRequestOptions> = {},\n    localState: Record<string, any> = {},\n  ): Promise<string> {\n    if (!this.options.endpoints?.authorization_endpoint) {\n      await this.initialize(false)\n    }\n    // TODO: deep merge for extra params\n    const finalOptions = Object.assign({}, this.options, options)\n    localState.code_verifier = generateRandom(72)\n\n    const authParams = {\n      client_id: finalOptions.client_id,\n      state: finalOptions.state || generateRandom(finalOptions.stateLength!),\n      scope: finalOptions.scope,\n      audience: finalOptions.audience,\n      redirect_uri: finalOptions.redirect_uri,\n      response_mode: finalOptions.response_mode,\n      response_type: finalOptions.response_type || \"code\",\n      ui_locales: finalOptions.ui_locales,\n      prompt: finalOptions.prompt,\n      display: finalOptions.display,\n      claims: finalOptions.claims,\n      claims_locales: finalOptions.claims_locales,\n      acr_values: finalOptions.acr_values,\n      nonce: finalOptions.nonce,\n      registration: finalOptions.registration,\n      login_hint: finalOptions.login_hint,\n      id_token_hint: finalOptions.id_token_hint,\n      web_message_uri: finalOptions.web_message_uri,\n      web_message_target: finalOptions.web_message_target,\n      ...(finalOptions.extraParams && finalOptions.extraParams),\n    } as AuthRequestOptions\n\n    if (\n      !authParams.nonce &&\n      (isResponseType(\"id_token\", authParams.response_type) ||\n        isScopeIncluded(\"openid\", authParams.scope))\n    ) {\n      authParams.nonce = generateRandom(finalOptions.nonceLength!)\n    }\n\n    if (isResponseType(\"code\", authParams.response_type)) {\n      authParams.code_challenge = await deriveChallenge(localState.code_verifier)\n      authParams.code_challenge_method = finalOptions.code_challenge_method || \"S256\"\n    }\n\n    const now = this.options.currentTimeInMillis?.() || Date.now()\n    const fragment = finalOptions.fragment ? `#${finalOptions.fragment}` : \"\"\n    const authParamsString = buildEncodedQueryString(authParams)\n    const url = `${this.options.endpoints!.authorization_endpoint}${authParamsString}${fragment}`\n\n    // clear 1 day old state entries\n    this.stateStore.clear(now - 86400000)\n\n    await this.stateStore.set(\n      authParams.state!,\n      cleanUndefined({\n        created_at: now,\n        authParams,\n        localState,\n        request_type: finalOptions.request_type,\n      }),\n    )\n    return url\n  }\n\n  /**\n   * Create a logout request with given options\n   *\n   * @param options\n   * @private\n   */\n  private async createLogoutRequest(options: LogoutRequestOptions = {}) {\n    if (!this.options.endpoints?.end_session_endpoint) {\n      await this.fetchFromIssuer()\n    }\n    const finalOptions = mergeObjects(this.options, options)\n    const logoutParams = {\n      id_token_hint: finalOptions.id_token_hint,\n      post_logout_redirect_uri: finalOptions.post_logout_redirect_uri,\n      ...(finalOptions.extraLogoutParams || {}),\n    }\n    return `${this.options.endpoints!.end_session_endpoint}${buildEncodedQueryString(logoutParams)}`\n  }\n\n  /**\n   * Exchange authorization code retrieved from auth request result.\n   * @param options\n   * @private\n   */\n  private async exchangeAuthorizationCode(options: TokenRequestOption) {\n    if (!this.options.endpoints?.token_endpoint) {\n      await this.fetchFromIssuer()\n    }\n    const finalOptions = mergeObjects(this.options, options)\n    const { extraTokenHeaders, extraTokenParams, ...rest } = finalOptions\n    const mergedOptions = {\n      ...rest,\n      ...(extraTokenParams || {}),\n      grant_type: \"authorization_code\",\n    }\n\n    for (const req of [\"code\", \"redirect_uri\", \"code_verifier\", \"client_id\"] as const) {\n      if (!mergedOptions[req]) {\n        return Promise.reject(new Error(`\"${req}\" is required`))\n      }\n    }\n\n    return this.http({\n      url: `${this.options.endpoints!.token_endpoint}`,\n      method: \"POST\",\n      requestType: \"form\",\n      body: mergedOptions as any,\n      headers: extraTokenHeaders,\n    })\n  }\n\n  /**\n   * Exchange refresh token with given options\n   * @param options\n   * @private\n   */\n  private async exchangeRefreshToken(options: Partial<TokenRequestOption>) {\n    if (!this.options.endpoints?.token_endpoint) {\n      await this.fetchFromIssuer()\n    }\n    const { extraTokenHeaders, extraTokenParams, ...rest } = options\n    const mergedOptions = {\n      grant_type: \"refresh_token\",\n      client_id: this.options.client_id,\n      client_secret: this.options.client_secret,\n      ...rest,\n      ...(extraTokenParams || {}),\n    }\n\n    for (const req of [\"refresh_token\", \"client_id\"] as const) {\n      if (!mergedOptions[req]) {\n        return Promise.reject(new Error(`\"${req}\" is required`))\n      }\n    }\n\n    return this.http({\n      url: `${this.options.endpoints!.token_endpoint}`,\n      method: \"POST\",\n      requestType: \"form\",\n      body: mergedOptions as any,\n      headers: extraTokenHeaders,\n    })\n  }\n\n  /**\n   * Fetch OIDC configuration from the issuer.\n   */\n  private async fetchFromIssuer(): Promise<Record<string, any>> {\n    try {\n      const requestUrl = `${this.options.issuer}/.well-known/openid-configuration`\n      const response = await this.http({\n        url: requestUrl,\n        method: \"GET\",\n        requestType: \"json\",\n      })\n      this.issuer_metadata = response as Record<string, any>\n      const endpoints = {} as any\n      for (const prop of Object.keys(this.issuer_metadata)) {\n        if (\n          prop.endsWith(\"_endpoint\") ||\n          prop.indexOf(\"_session\") > -1 ||\n          prop.indexOf(\"_uri\") > -1\n        ) {\n          endpoints[prop as keyof IEndpointConfiguration] = this.issuer_metadata[prop]\n        }\n      }\n      this.options.endpoints = endpoints\n      return this.issuer_metadata\n    } catch (e) {\n      throw new OIDCClientError(\"Loading metadata failed\", e.message)\n    }\n  }\n\n  /**\n   * Handle auth request result. If there is `code` exchange it.\n   * @param response\n   * @param finalOptions\n   * @param localState\n   * @private\n   */\n  private async handleAuthResponse(\n    response: any,\n    finalOptions: AuthRequestOptions,\n    localState: Record<string, any> = {},\n  ) {\n    if (response.code) {\n      return this.exchangeAuthorizationCode({\n        redirect_uri: finalOptions.redirect_uri,\n        client_id: finalOptions.client_id,\n        code_verifier: localState.code_verifier,\n        grant_type: \"authorization_code\",\n        code: response.code,\n      })\n    }\n    return response\n  }\n\n  /**\n   * Handle OAuth2 auth request result\n   * @param tokenResult\n   * @param authParams\n   * @param finalOptions\n   * @private\n   */\n  private async handleTokenResult(\n    tokenResult: TokenResponse,\n    authParams: AuthRequestOptions,\n    finalOptions: IPlusAuthClientOptions,\n  ) {\n    await this.initialize(false)\n    let user: any = {}\n    if (tokenResult.error) {\n      throw new AuthenticationError(tokenResult.error, tokenResult.error_description)\n    }\n    let parsedIDToken: any\n    if (tokenResult.id_token) {\n      parsedIDToken = await validateIdToken(tokenResult.id_token, authParams.nonce!, finalOptions)\n      if (\n        finalOptions.idTokenValidator &&\n        !(await finalOptions.idTokenValidator(tokenResult.id_token))\n      ) {\n        return Promise.reject(new InvalidIdTokenError(\"Id Token validation failed\"))\n      }\n      Object.keys(parsedIDToken).forEach((key) => {\n        if (!nonUserClaims.includes(key as any)) {\n          user[key] = parsedIDToken[key]\n        }\n      })\n    }\n\n    if (tokenResult.access_token) {\n      if (finalOptions.requestUserInfo && this.options.endpoints?.userinfo_endpoint) {\n        const userInfoResult = await this.fetchUserInfo(tokenResult.access_token)\n        if (!userInfoResult.error) {\n          user = { ...user, ...userInfoResult }\n        }\n      }\n    }\n\n    return {\n      authParams,\n      user,\n      ...tokenResult,\n      id_token: parsedIDToken,\n      id_token_raw: tokenResult.id_token,\n      scope: tokenResult.scope !== undefined ? tokenResult.scope : authParams.scope,\n    }\n  }\n\n  /**\n   * Load stored state\n   *\n   * @param state\n   * @private\n   */\n  private async loadState(state: string) {\n    const rawStoredState = await this.stateStore.get(state)\n    if (!rawStoredState) {\n      return Promise.reject(new StateNotFound(\"Local state not found\", state))\n    }\n    await this.stateStore.del(state)\n    return rawStoredState\n  }\n\n  /**\n   * Load user info by making request to providers `userinfo_endpoint`\n   *\n   * @param accessToken\n   * @private\n   */\n  private async fetchUserInfo(accessToken: string) {\n    return this.http({\n      method: \"GET\",\n      url: `${this.options.endpoints!.userinfo_endpoint}`,\n      requestType: \"json\",\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n      },\n    })\n  }\n\n  /**\n   * Start monitoring End-User's session if the OIDC provider supports session management. See more at [OIDC Session\n   * Management](https://openid.net/specs/openid-connect-session-1_0.html)\n   *\n   * @param sub End-User's id to for monitoring session\n   * @param session_state string that represents the End-User's login state at the OP\n   */\n  private monitorSession({ sub, session_state }: SessionMonitorOptions) {\n    const { client_id, endpoints } = this.options\n\n    if (!endpoints?.check_session_iframe) {\n      console.warn(\n        '\"check_session_iframe\" endpoint missing or session management is not supported by provider',\n      )\n      return\n    }\n    if (!this.sessionCheckerFrame) {\n      const sessionCheckCallback = async (err: any) => {\n        if (err) {\n          this.emit(Events.USER_LOGOUT)\n        } else {\n          this.emit(Events.SESSION_CHANGE)\n          try {\n            await this.silentLogin({}, {})\n            const storedAuth = await this.authStore.get(\"auth\")\n            if (storedAuth) {\n              if (storedAuth.user?.sub === sub && storedAuth.session_state) {\n                this.sessionCheckerFrame!.start(storedAuth.session_state)\n              }\n            } else {\n              this.emit(Events.USER_LOGOUT, null)\n            }\n          } catch (_e) {\n            this.emit(Events.USER_LOGOUT)\n            return\n          }\n        }\n      }\n\n      this.sessionCheckerFrame = createSessionCheckerFrame({\n        url: endpoints.check_session_iframe,\n        client_id: client_id,\n        callback: sessionCheckCallback,\n        checkInterval: this.options.checkSessionInterval,\n      })\n    }\n\n    this.sessionCheckerFrame.start(session_state)\n  }\n\n  private async onUserLogin(authObj: any, isInternal = false) {\n    const {\n      expires_in,\n      user,\n      scope,\n      access_token,\n      id_token,\n      refresh_token,\n      session_state,\n      id_token_raw,\n    } = authObj\n    await this.authStore.set(\"auth\", authObj)\n\n    this.user = user\n    this.scopes = scope?.split(\" \").filter(Boolean)\n    this.accessToken = access_token\n    this.idToken = id_token\n    this.idTokenRaw = id_token_raw\n    this.refreshToken = refresh_token\n\n    if (!isInternal) {\n      this.emit(Events.USER_LOGIN, authObj)\n    }\n    if (!window?.frameElement) {\n      if (this.options.checkSession) {\n        this.monitorSession({ sub: user.sub || user.id, session_state })\n      }\n\n      if (expires_in !== undefined && this.options.autoSilentRenew) {\n        const expiration = Number(expires_in) - this.options.secondsToRefreshAccessTokenBeforeExp!\n        const renew = () => {\n          this.synchronizer.CallOnce(\"silent-login\", async () => {\n            try {\n              await this.silentLogin()\n              this.emit(Events.SILENT_RENEW_SUCCESS, null)\n            } catch (e) {\n              this.emit(Events.SILENT_RENEW_ERROR, e)\n            }\n          })\n        }\n        if (expiration >= 0) {\n          this._accessTokenExpireTimer!.start(expiration, async () => {\n            renew()\n          })\n        } else {\n          renew()\n        }\n      }\n    }\n  }\n}\n","import { OIDCClient } from \"./client\"\nimport type { IPlusAuthClientOptions } from \"./interfaces\"\n\nexport * from \"./client\"\nexport * from \"./constants\"\nexport * from \"./errors\"\nexport * from \"./helpers\"\nexport * from \"./interfaces\"\nexport { DefaultIframeAttributes } from \"./utils\"\n\n/**\n * Create OIDC client with initializing it. It resolves issuer metadata, jwks keys and check if user is\n * authenticated in OpenId Connect provider.\n */\nexport default function createOIDCClient(options: IPlusAuthClientOptions): Promise<OIDCClient> {\n  return new OIDCClient(options).initialize()\n}\n"],"mappings":"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"}